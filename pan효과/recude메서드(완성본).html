<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
 <script>
   //iterable.reduce : 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백함수를 반복호출한다.
  //콜백함수의 반환값을 다음 순회시에 콜백 함수의 첫번째 인수로 전달 함녀서 콜백함수를 호출하여 하나의 결과값을 만들어 반환한다.

  const sum = [1,2,3,4];
  //acc = 누적값, cur = 현재 순회중인 배열요소
  const num = sum.reduce((acc,cur) => acc + cur,0)
  console.log(num)

  //평균 구하기
  const values = [1,2,3,4,5,6];
  //acc = 누적값, cur = 현재 순회중인 배열요소, i = 현재 순회중인 인덱스, {length} = 배열의 길이
  const average = values.reduce((acc,cur,i, {length}) => {
    //마지막 순회가 아니면 누적값을 반환하고 마지막 순회면 누적값을 배열의 길이로 나눈 평균값을 반환한다.
    return i === length - 1 ? (acc + cur) / length : acc + cur
  },0)
  console.log(average)

  //최대값 구하기
  const max = values.reduce((acc,cur) => acc > cur ? acc : cur,0)
  console.log(max)

  //Math.max 메서드를 사용하는 방법이 더 직관적이다.
  const max2 = Math.max(...values)
  console.log(max2)

  //요소의 중복 횟수 구하기
  const fruits = ['banana','apple','orange','orange','apple']
  const count = fruits.reduce((acc,cur) => {
    acc[cur] = (acc[cur] || 0) + 1;
    return acc;
  },{})//첫번째 순회시 acc는 빈 객체이다.
  console.log(count)
 </script>

</body>
</html>